

### python建图的三种常见方式
```
import collections
if __name__ == "__main__":
    # 有向图节点个数为10
    n = 10
    # g中的每一个顶点都是一个列表, 这样就可以往对应顶点添加出边以及对应的权重
    g = [list() for i in range(n)]
    # 有向图中存在边: 1->2
    g[1].append(2)
    # 有向图存在边: 2->4, 并且权重为5
    g[2].append((4, 5))
    print(g)
 
    n = 10
    # 列表中的每一个元素为一个字典这种方式比较适合于有向边存在权重的情况
    g = [dict() for i in range(n)]
 
    # 有向图存在边: 3->4, 并且权重为10
    g[3][4] = 10
    print(g)
 
    n = 10
    g = collections.defaultdict(list)
    # 有向图存在边: 1->2
    g[1].append(2)
    # 有向图存在边: 1->2, 并且权重为3
    g[1].append((2, 3))
    print(g)
 
    # 无向图以上面其中一种方式为例, 其余的两种方式也是类似的
    n = 10
    g = [list() for i in range(n)]
    # 1与2之间有一条无向边
    g[1].append(2)
    g[2].append(1)
    print(g)

```

### 列表
* 求`items(),keys(),values()`的长度
* 转为`list`
```
dict_var = {1: 2, 2: 3, 3: 4}
result = dict_var.items()
list_var = list(result)  # 转换为列表类型
print(list_var)

dict_var = {1: 2, 2: 3, 3: 4}
result = dict_var.keys()
list_var = list(result)  # 转换为列表类型
print(list_var)

dict_var = {1: 2, 2: 3, 3: 4}
result = dict_var.values()
list_var = list(result)  # 转换为列表类型
print(list_var)

```
### 元组
* 元组无法使用`append()`和`add()`来添加元素
* 

### readline()
* 只能读取一行


### set类型

```

# 重复的操作在set中自动被过滤
set1 = {1, 2, 3, (4, 5, 6), "good news"}

set2 = set([1, 2, 3])                 #相当于set2 = {1, 2, 3}， set函数只能传入一个参数
set3 = set((1,2,3))　　                #相当于set3 = {1,2,3}
set4 = set({'a':1,'b':2,'c':3})　      #相当于set4 = {'a','b','c'}


# 2，通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果
'''
遇到问题没人解答？小编创建了一个Python学习交流QQ群：579817333 
寻找有志同道合的小伙伴，互帮互助,群里还有不错的视频学习教程和PDF电子书！
'''
>>> s = {1, 2, 3}
>>> s.add(4)
>>> s
{1, 2, 3, 4}
>>> s.add(4)
>>> s
{1, 2, 3, 4}

# 通过 remove(key) 方法可以删除元素
>>> s = {1, 2, 3, 4}
>>> s.remove(4)
>>> s
{1, 2, 3}

# 两个set可以做数学意义上的交集、并集等操作
'''
遇到问题没人解答？小编创建了一个Python学习交流QQ群：579817333 
寻找有志同道合的小伙伴，互帮互助,群里还有不错的视频学习教程和PDF电子书！
'''
>>> s1 = set([1, 2, 3])
>>> s2 = set([2, 3, 4])
>>> s1 & s2
{2, 3}
>>> s1 | s2
{1, 2, 3, 4}


```

### map函数


```
del square(x):
    return x ** 2
 
map(square,[1,2,3,4,5])
 
# 结果如下:
[1,4,9,16,25]


# 通过使用lambda匿名函数的方法使用map()函数：

map(lambda x, y: x+y,[1,3,5,7,9],[2,4,6,8,10])
 
# 结果如下：
[3,7,11,15,19]


# 通过lambda函数使返回值是一个元组：

map(lambdax, y : (x**y,x+y),[2,4,6],[3,2,1])
 
# 结果如下
[(8,5),(16,6),(6,7)]


# 当不传入function时，map()就等同于zip()，将多个列表相同位置的元素归并到一个元组：

map(None,[2,4,6],[3,2,1])
 
# 结果如下
[(2,3),(4,2),(6,1)]


# 通过map还可以实现类型转换，将元组转换为list：

map(int,(1,2,3))
 
# 结果如下：
[1,2,3]

# 将字符串转换为list：
map(int,'1234')
 
# 结果如下：
[1,2,3,4]

# 提取字典中的key，并将结果放在一个list中：
map(int,{1:2,2:3,3:4})
 
# 结果如下
[1,2,3]

```




## 题目

### 题目1
#### Write a function temp_query(data_file, query_file, result_file), where:
* data_file is a string that contains the file name of the dataset;
* query_file is a string that contains the file name of the file to be processed
* result_file is a string that contains the file name of the file to be saved.

#### The input and output files are in CSV format
* The input file 1 (dataset) has no header, it contains two columns in each row. 
    * The first column is the city name;
    * The second column is the temperature value
* The input file 2 (query) has no header, it only contain one column in each row 
    * The only column in this file is the querying city name.
#### You are expected to find the temperature value from the input file (dataset) andappend that value in each corresponding row.
* When the city name does not exist in the dataset, use None as the value (seethe example below).
* The function does not return anything, only to create the result_file andinclude the query results.
#### Example of data_file: dataset.csV
```
Melbourne,35
Sydney , 36
Guangzhou,16
Seoul,22
Munich,3
San Jose,35
```
#### Example of query_file: query.csv
```
San Jose
Sydney
Munich
Santa Clara
```
#### Expected of result_file: result.csv (generated by your program)
```
San Jose,35
Sydney, 36
Munich,3
Santa Clara,None
```

#### Note:
* You can only use the csv library with import csv. 
* All the above CSV files does not have a newline character ('  n') at the endof the file.
* The dataset will not contain repeated city names, however, the output filemay contain repeated city names.

#### 代码
```
import csv

#print("Hello")

def temp_query(data_file, query_file, result_file):
    result_map={}
    with open(data_file) as data:
        lines = data.readlines()
        #print(lines)
        for line in lines:
            cities = line.split(",")
            #print(cities)
            city=cities[0]
            age=cities[1].rstrip('\n')
            result_map[city]=age
            # print(city,age)
            
    # print(result_map)   
    # print("====")
    with open(query_file) as data:
        lines = data.readlines()
        # print(lines)
        f = open(result_file, 'w')
        for line in lines:
            res_line=line[:-1]
            if  res_line in result_map.keys():
                res=res_line+","+result_map[res_line]+"\n"
                #print(res)
                f.writelines(res)
                
            else:
                res=res_line+",None"+"\n"
                #print(res)
                f.writelines(res)
        f.close()    
        
    #print("====")  
    with open(result_file) as data:
        lines = data.readlines()
        # print(lines)
    
    
result_file=temp_query("dataset.csv","query.csv","result_file.csv")

```

### 题目2
####  [7 marks] Write a function search(text，pattern) to search a piece of text fora certain pattern. Both inputs are strings. The output shoud be a list containing theindex positions within text where the first character of the pattern string occurs. Forexample:
```
>>> search('abc abcd adc','abc')
[0, 4]
```
#### because the string 'abc' occurs twice within text, with the character 'a' occuringin index postions 0 and 4.
#### The function also needs to support the special character '? ', which is used as a'don't care' character. For example if the pattern is 'a?c', then the function searchesfor strings of length 3, with 'a' in the first postion and 'c' in the third, and anycharacter between them. The '?' character may be used multiple times, in anyocation.
#### lf the pattern is not found, the function should return an empty list
#### (b) 18 marks Now extend your program to include the use of a pair of charactersi* . .* i, to indicate a string pattern whose order may be reversed. For example,*abc* can match both  abc' andicba'
#### You can assume '?' will not be inserted within '*..*i Thus for example, you don'tneed to consideri*A?*!
#### Here are examples of how your program should work:


```
>>> search('abc abcd adc','abc')
[0, 4]
>>> search('abc abcd adc','a?c')vvv
[0, 4, 9]
>>> search('abc abcd ab abcde a' , 'a??')
[0， 4, 9, 12]
>>> search('abc abcd ab abcde a', '123')
[]
>>> search('COMP90086 and COMP90059 ，COMP9???9')
[14]
>>> search('COMP9011 and ELEN90011'，????90011')
[0，14]
>>> search('COMP1221 and COPM1221'，CO*PM*')
[0, 13]
>>> search('COMP1221 and CMPM1221'，C?*PM*')
[0, 13]
>>> search('lab2cd3 1ba2dc3 1ba2cd3'，1*ab*2*cd*3')
[0, 8, 16]
>>> search('123421432134124321!i*12**34**12*1)
[0, 4, 8, 12]

```

#### Note:
* You cannot use/import any libraries
* You are recommended to write several (short) helper functions. Thus, youcan easily check whether your helper function works. Your reasonablycorrect helper function will take into consideration in marking.
* You do not need to use recursion to complete this question.
* Hint: [s1 + s2 for sl in 'abc' for s2 in '123']


#### 代码
```
CODES = ['a, e, i, o, u, y, h, w', 'b, f, p, v', 
         'c, g, j, k, q, s, x, z', 'd, t', 'l', 'm, n', 'r']
dic={}
dic={'a':'0','e':'0','i':'0','o':'0','u':'0','y':'0','h':'0','w':'0','b':'1',
'f':'1','p':'1','v':'1','c':'2','g':'2','j':'2','k':'2','q':'2','s':'2',
'x':'2','z':'2','d':'3','t':'3','l':'4','m':'5','n':'5','r':'6'}



def transform(word):
    tmpres=word[0]
    for w in word[1:]:
        # print(w)
        tmpres+=dic[w]
    
    res=""
    for w in tmpres:
        if w!='0':
            res+=w
    #print(res)
    
    dic1={}
    for w in res[1:]:
        if w in dic1.keys():
            dic1[w]+=1
        if w not in dic1.keys():
            dic1[w]=1
    #print(dic1)
    dic2=dic1
    
    print(res[0],end = "")
    for w in res[1:]:
        if dic2[w]>1:
            if dic1[w]==dic2[w]:
                print(w,end="")
            dic1[w]-=1
        else:
            print(w,end="")
    print()
    
transform("robert")
transform("ruppert")
transform("roubart")
transform("hobart")
transform("people")
transform("peeeeeeeeeeooopppppplee")

```

### 题目3
#### A friend network represents friend relationship in a list of tuples, e.g.
```
friends = [('alice', 'bob' ) , ('bob', 'david') ,( 'bob' , 'mark'), ('alice' , 'mark' ) ,('raina' , 'david') , ('clara', iian')]
```
#### represents
* Alice and Bob are friends;
* Bob and David are friends;
* Bob and Mark are friends
* Alice and Mark are friends.
* Raina and David are friends.
* Clara and lan are friends.


#### Write a function friend_dist(friends， p1，p2) that takes
* 1. A list representing friend network (in the above format);
* 2. The name of the first person as a non-empty string;
* 3.The name of the second person as a non-empty string.
#### lt returns the minimum distance between the two people (p1 and p2). lf the given two peopleare not indirectly friends or any person's name is not found in the list, return -1.

#### For example:

* friend_dist(friends, 'alice', 'mark') returns 1 
    * since Alice and Mark are directly friends
* friend_dist(friends, 'mark','alice') returns 1
* friend_dist(friends, 'alice','david') returns 2
    * since Alice -> Bob -> David
* friend_dist(friends, 'mark'' david' ) returns 2
    * since Mark -> Bob-> David
* friend_dist(friends, 'mark','raina') returns 3 
    * since Mark -> Bob -> David -> Raina
* You can assume all names in the list are lowercased, and there won't be
    * duplicates (e.g.[('alice' ,'bob'), ('alice' , 'bob')]), or
    * inverses (e.g.[('alice' , 'bob') , ('bob','alice')]).

#### For example:
```

>>> friend_dist(friends, 'alice', 'mark')
1
>>> friend_dist(friends, 'mark','alice')vvv
1
>>> friend_dist(friends,'alice','david')vvv
2
>>> friend_dist(friends, 'mark', 'david')
2
>>> friend_dist(friends, 'mark', 'raina')
3
>>> friend_dist(friends, 'mark', 'peter')
-1
>>> friend dist(friends, 'ian' , 'raina')
-1
```

#### 代码
```
def friend_dist(friends,p1,p2):
    st=set()
    for friend in friends:
        st.add(friend[0])
        st.add(friend[1])
    print(st)
    n=len(st)
    # print(n)
    g = [list() for i in range(n+1)]
    dic={}
    for friend in friends:
        if friend[0] not in dic.keys():
            dic[friend[0]]=len(list(dic.keys()))+1
        if friend[1] not in dic.keys():
            dic[friend[1]]=len(list(dic.keys()))+1
        print(friend[0],dic[friend[0]])
        print(friend[1],dic[friend[1]])
        e0=dic[friend[0]]
        e1=dic[friend[1]]
        g[e0].append(e1)
        g[e1].append(e0)
    
    
    for g1 in g:
        print(g1)


friends = [('alice', 'bob'), ('bob', 'david'), 
           ('bob', 'mark'),  ('alice', 'mark'), 
           ('raina', 'david'), ('clara', 'ian')]
p1='mark'
p2='david'

friend_dist(friends,p1,p2)

```


## 测试题目
### 题目1
`get_tfidf`函数的两个参数
* `docs`, 文档，以一个字典的形式（`keys`和`values`都是`string`）
* `query`, 字符串形式（一个简单的word）
* 返回带有相关分数的文档字典

#### 相关分数计算如下：一个简单`TF*IDF`
* 1，`TF(term frequency)= f(t,d)/len(d)`；`f(t,d)`是在`文档d`中`term t(query word)`；`len(d)`是在`文档d`中`term(words)的总数`
* 2，`IDF(inverse document frequency)`；`idf=N/n(t)`，N是文档的总数，`n(t)`是包含`term t(query word)`的文档总数

#### 如果```term t```不出现在corpus中，它的分数应该是0。
You should assume that sentences do not contain punctuation and words can be identified using white space. Documents and the query string should be lowercased.


#### 函数应该包含一个大体的docstring,comments,和可读性的好的变量名

#### 例如
* In the case of docs being the dictionary {'doc1':'A cat sat on the mat', 'doc2':'A cat had a kitten', 'doc3':'I love ice cream'} and query being the string 'cat' , the fuction should return "{'doc1':0.25; 'doc2': 0.3; 'doc3': 0}" (i.e doc1: 1/6 x 3/2; doc2: 1/5 x 3/2; doc3: 0)
* If docs or query is empty, the function should return None.

#### Some example calls to the function are:
```
>>> get_tfidf({'doc1':'A cat sat on the mat', 'doc2':'A cat had a kitten', 'doc3':'I love ice cream'}, 'cat')
{'doc1':0.25,'doc2':0.3, 'doc3':0}
>>> get_tfidf({},'')
None
>>> get_tfidf({'doc1':'A cat and a cat', 'doc2':'A cat had a kitten', 'doc3':'I love the cat'}, 'cat')
{'doc1':0.4,'doc2':0.2, 'doc3':0.25}
(0.4=2/5x3/3; 1/5x3/3; 1/4x3/3)
```



