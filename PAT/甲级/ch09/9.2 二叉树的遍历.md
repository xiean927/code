

### 构造树，记住 前序+中序 构造的代码，而后可直接退出 后序+中序 构造的代码

* 建树1

```
struct node{
	int data;
	node* lchild;
	node* rchild;
	node(int val){
        data=val;
        lchild=rchild=NULL;
	}
};

///先序和中序，那叫构建树,而非求出后序
node* create(int inL,int inR,int postL,int postR){
	if(postL>postR)
		return NULL;
	//node* root = new node;
	//root->data = pre[preL];
	node* root=new node(post[postR]);

```

* 建树2

```
struct node{
	int data;
	node* lchild;
	node* rchild;
};

///先序和中序，那叫构建树,而非求出后序
node* create(int inL,int inR,int postL,int postR){
	if(postL>postR)
		return NULL;
	node* root = new node;
	root->data = post[postR];
	

```


### 1086 Tree Traversals Again (25分)


* 1，树节点定义
```
struct node{
	int data;
	node* lchild;
	node* rchild;
	node(int val){
        	data=val;
        	lchild=rchild=NULL;
	}
};
```

* 2，前序+中序遍历树（关键在于如何生成新的树结点）

```
///先序和中序，那叫构建树,而非求出后序
node* create(int preL,int preR,int inL,int inR){
	if (preL>preR)
		return NULL;
	//node* root = new node;
	//root->data = pre[preL];
	node* root=new node(pre[preL]);
	int k;
	for (k=inL;k<inR;k++){
		if(in[k]==root->data)
			break;
	}
	int numLeft=k-inL;
	root->lchild=create(preL+1,preL+numLeft,inL,k-1);
	root->rchild=create(preL+numLeft+1,preR,k+1,inR);
	return root;
}

```

* 3，后序遍历
  * 将打印部分封装成函数
```
int num = 0;
void print(int id){
	printf("%d",id);
	num++;
	if(num<n)
		printf(" ");
	else
		printf("\n");
}

void postorder(node* root){
	if (root==NULL)
		return;
	postorder(root->lchild);
	postorder(root->rchild);
	print(root->data);
}
```

* 4，处理输入
```
int main() {
	stack<int> st;
	string str;
	scanf("%d",&n);
	int prenum=0,innum=0;
	getchar();
	///入栈(前序遍历树)1,2,3,4,5,6
  ///出栈(中序遍历树LDR)3,2,4,1,6,5

	while(getline(cin,str)){
		if(str[1]=='u'){//Push
			string nums=str.substr(4);///截取结点编号
			int num=atoi(nums.c_str());
			st.push(num);
			pre[prenum++]=num;
		}
		else {//Pop
			int num=st.top();
			st.pop();
			in[innum++]=num;
		}
		if (innum==n)//控制结束循环
			break;
	}
	node* root=create(0,n-1,0,n-1);
	postorder(root);
	return 0;
}
```


### 1020 Tree Traversals (25分)

* 1，中序+后序 构造树
```
///先序和中序，那叫构建树,而非求出后序
node* create(int inL,int inR,int postL,int postR){
	if(postL>postR)
		return NULL;
	//node* root = new node;
	//root->data = pre[preL];
	node* root=new node(post[postR]);
	int k;
	for (k=inL;k<inR;k++){
		if(in[k]==root->data)
			break;
	}
	int numLeft=k-inL;
	root->lchild=create(inL,k-1,postL,postL+numLeft-1);
	root->rchild=create(k+1,inR,postL+numLeft,postR-1);
	return root;
}

```

* 2，树的层序遍历
```
int num=0;
void bfs(node* root){
    queue<node*> q;
    q.push(root);
    while(!q.empty()){
        node* fr=q.front();
        q.pop();
        printf("%d",fr->data);
        num++;
        if(num<n)   printf(" ");
        if(fr->lchild!=NULL)    q.push(fr->lchild);
        if(fr->rchild!=NULL)    q.push(fr->rchild);
    }
}

```



### 1102 Invert a Binary Tree (25分)

* 0，静态链表建树
```
void strtoint(int id,char c1,char c2){
    if(c1=='-')     nd[id].lchild=-1;
    else{
        nd[id].lchild=c1-'0';
        notRoot[c1-'0']=true;
    }

    if(c2=='-')     nd[id].rchild=-1;
    else{
        nd[id].rchild=c2-'0';
        notRoot[c2-'0']=true;
    }
}

int main(){
    memset(notRoot,0,sizeof(notRoot));
    scanf("%d",&n);
    for(int i=0;i<n;i++){
        char c1,c2;
        //getchar();
        scanf("%*c%c %c",&c1,&c2);//%*c  相当于  getchar()
        strtoint(i,c1,c2);
    }
    
    


```


* 1，后序遍历交换一棵树的左右子树

```
void postOrder(int root){
    if(root==-1)///一开始想不通为什么root是-1,
        return ;
    postOrder(nd[root].lchild);
    postOrder(nd[root].rchild);
    swap(nd[root].lchild,nd[root].rchild);
}
```
* 2，层序遍历

```
void BFS(int root){
	queue<int> q;
	q.push(root);
	while(!q.empty()){
		int now = q.front();
		q.pop();
		print(now);
		if(nd[now].lchild!=-1)
			q.push(nd[now].lchild);
		if(nd[now].rchild!=-1)
			q.push(nd[now].rchild);
	}
}

```

### 1115 Counting Nodes in a BST (30分)

```
struct node {
	int data;
	node* lchild;
	node* rchild;
    	node(int val){///①
        	data=val;
        	lchild=rchild=NULL;
	}
///	int layer;
};
node* newNode(int val) {②
	node* Node = new node;
	Node->data = val;
	Node->lchild = Node->rchild = NULL;
	return Node;
}

①和②只能留一个，否则报错

```













