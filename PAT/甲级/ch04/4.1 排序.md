
### 1141 PAT Ranking of Institutions (25分) 与 1153 Decode Registration Card of PAT (25分)题目类似

### 1137 Final Grading (25分)
* 其中的```0不记录```思想，值得思考


### 1006 Sign In and Sign Out (25分)
* 针对时间排序，转换成数字
```
int signin=hh1*3600+mm1*60+ss1;
int signout=hh2*3600+mm1*60+ss2;
```

### 1012 The Best Rank (25分)

* 1,按优先级顺序存储字母，方便输出
```
char course[4]={'A','C','M','E'};///按优先级顺序,方便输出

int query;///查询的考生ID
for(int i=0;i<m;i++){
    scanf("%d",&query);
    if(Rank[query][0]==0)
        printf("N/A\n");
    else{
        int k=0;
        for(int j=0;j<4;j++)
            if(Rank[query][j]<Rank[query][k])   k=j;
        printf("%d %c\n",Rank[query][k],course[k]);
    }
}
```
* 2,平均数取整
```
for(int i=0;i<n;i++){
    scanf("%d%d%d%d",&stu[i].id,&stu[i].grade[1],&stu[i].grade[2],&stu[i].grade[3]);
    stu[i].grade[0]=(stu[i].grade[1]+stu[i].grade[2]+stu[i].grade[3])/3.0+0.5;
}
```
* 3,按照```now```编号排序
```
int now;///cmp函数中使用,表示当前按now号分数排序stu数组

bool cmp(const Student &a,const Student &b){
    return a.grade[now]>b.grade[now];
}

///枚举A,C,M,E 4个中的一个
for(now=0;now<4;now++){
    sort(stu,stu+n,cmp);///对所有考生按该分数从大到小排序
    Rank[stu[0].id][now]=1;///排序完，将分数最高的设为rank1
    for(int i=1;i<n;i++){///对于剩下的考生
        ///若与前一位考生分数相同
        if(stu[i].grade[now]==stu[i-1].grade[now]){
            Rank[stu[i].id][now]=Rank[stu[i-1].id][now];///则他们的排名相同
        }
        else{
            Rank[stu[i].id][now]=i+1;///否则，为其设置正确的排名
        }
    }
}
```


### 1016 Phone Bills (25分)
* 1,利用数组最后一位记录一整天的通话费用
```
double billFromZero(node call, int *rate) {
    ///在该小时下分钟数*该小时下的通话费用 + 天数*（各个时间段的通话费用（按小时划分，共24小时））*60
	double total = rate[call.hour] * call.minute + rate[24] * 60 * call.day;
	//计算每分钟的费用               +             每天的费用
    ///计算call.hour之前小时的通话总费用，
	for (int i = 0; i < call.hour; i++)
		total += rate[i] * 60;
	//计算每小时的费用
	
	return total / 100.0;
	//转换为正常的费用
}

int rate[25] = { 0 }, n;
for (int i = 0; i < 24; i++) {
  scanf("%d", &rate[i]);
  rate[24] += rate[i];///24小时各个时间段的费用:通话每分钟的费用
}
```
* 2,把时间转换为分钟
```
for (int i = 0; i < n; i++) {
  cin >> data[i].name;
  scanf("%d:%d:%d:%d", &data[i].month, &data[i].day, &data[i].hour, &data[i].minute);
  string temp;
  cin >> temp;
  data[i].status = (temp == "on-line") ? 1 : 0;
  data[i].time = data[i].day * 24 * 60 + data[i].hour * 60 + data[i].minute;///time是以分钟为单位
}
```

* 3,按照姓名记录通话记录
```
map<string, vector<node> > custom;
for (int i = 1; i < n; i++) {///输入合法的通话记录
  if (data[i].name == data[i - 1].name&&data[i - 1].status == 1 && data[i].status == 0) {
    custom[data[i - 1].name].push_back(data[i - 1]);
    custom[data[i].name].push_back(data[i]);
  }
}

```

### 1025 PAT Ranking (25分)
* 1,分考场排序
```
for (int i = 1; i <= n; i++) {
	int k;
	cin >> k;
	for (int j = 0; j < k; j++) {
		cin >> per[tmp + j].num >> per[tmp + j].scr;
		per[tmp + j].localnumber = i;
	}
	//这步操作牛！！！！！！！！！
	sort(per + tmp, per + tmp + k, cmp);///对tmp~tmp+k-1的人进行排序，也就是对每个考场的人进行排序
	per[tmp].localrank = 1;///
	//j=tmp+1
	for (int j = tmp+1; j <tmp + k; j++) {
		if (per[j].scr != per[j - 1].scr)
			per[j].localrank = j - tmp + 1;//输出对应的当前名次，肯定不能是第1，是第2,
		else
			per[j].localrank = per[j - 1].localrank;
	}
	tmp += k;
}
```
* 2,总人数排序
```
per[0].finalrank = 1;
for (int i = 1; i < tmp; i++) {
	if (per[i].scr != per[i - 1].scr)
		per[i].finalrank = i + 1;//输出对应的当前名次，肯定不能是第1，
	else
		per[i].finalrank = per[i - 1].finalrank;
}
```
### 1028 List Sorting (25分)
* 1,用```string```会超时
  * ```strcmp```的使用
```
bool cmp2(student a, student b) {
	//if (a.name != b.name)
	//	return a.name < b.name;
	if(strcmp(a.name,b.name))
        	return strcmp(a.name,b.name)<0;
	else
		return a.number < b.number;
}
```

### 1055 The World's Richest (25分)
#### 1,先排序，在选出在每个年龄下财富值前100的人
  * （1）,以下代码错误，因为未排序
```
for(int i=0;i<N;i++){
    scanf("%s %d %d",per[i].name,&per[i].age,&per[i].worth);
    if(book[per[i].age]<100){///每个年龄的人数要小于100,才可以计数
         vec.push_back(per[i]);
         book[per[i].age]++;
    }
}
sort(vec.begin(),vec.end(),cmp);
```
  * （2）,应先排序，再筛选
  ```
    for(int i=0;i<N;i++){
        scanf("%s %d %d",per[i].name,&per[i].age,&per[i].worth);
        //if(book[per[i].age]<100){///每个年龄的人数要小于100,才可以计数
        //    vec.push_back(per[i]);
        //    book[per[i].age]++;
        //}
    }
    sort(per,per+N,cmp);
    for(int i=0;i<N;i++){
        //scanf("%s %d %d",per[i].name,&per[i].age,&per[i].worth);
        if(book[per[i].age]<100){///每个年龄的人数要小于100,才可以计数
            vec.push_back(per[i]);
            book[per[i].age]++;
        }
    }
  ```

### 1062 Talent and Virtue (25分)
* 把分类成员按照标准分成几类
```
bool cmp(info a,info b){
    if(a.clas != b.clas) return a.clas < b.clas;
    else if(a.sum != b.sum) return a.sum > b.sum;
    else if(a.de_s != b.de_s) return a.de_s > b.de_s;
    else return strcmp(a.num,b.num) < 0;
}

for(int i = 0;i < N; i++) {
    scanf("%s %d %d",&stu[i].num,&stu[i].de_s,&stu[i].cai_s);
    stu[i].sum = stu[i].de_s + stu[i].cai_s;
    if(stu[i].de_s < L || stu[i].cai_s < L) {//德才分有一个不及格 的人 不会被记录 5
        stu[i].clas = 5;
        cnt--;//及格人数减少1 
    }
    else if(stu[i].de_s >= H && stu[i].cai_s >= H) stu[i].clas = 1;//德才分不低于H的,称为“sages”,按总分的递增序排序 1
    else if(stu[i].de_s >= H && stu[i].cai_s < H) stu[i].clas = 2;//才分低于H,但德分高于H,称为"noblemen",按总分的递增序排序 2
    else if(stu[i].de_s < H && stu[i].cai_s < H && stu[i].de_s >= stu[i].cai_s) stu[i].clas = 3;//德才分均低于H,但德分不低于才分被称为"fool men" 3
    else stu[i].clas = 4;//剩余的人排在最后 4
}
```

### 1075 PAT Judge (25分)

* [给了提示的代码](https://blog.csdn.net/weixin_43108373/article/details/84714215)
* 存在一种情况，就是选手可能第一次提交的分数>0,之后提交的代码编译不了，得分为-1，不能覆盖之前的得分

```
for (int i = 0; i < m;i++) {
	int tmp,num,score;
	cin >> tmp >> num >> score;
	if (score == -1) {///说明提交过
	      if(stu[tmp].scr[num]==-1)//选手可能第一次提交的分数>0,之后提交的代码编译不了，得分为-1，不能覆盖之前的得分
	      				//所以得加上这一句
		    stu[tmp].scr[num] = 0;
	}
	else {///存在满分情况，多次提交
		//if (problem_full[num] == score) {
	//		stu[tmp].perfect_pro++;
	//	}
		if(score>stu[tmp].scr[num])///更新最大分数
			stu[tmp].scr[num] = score;
		stu[tmp].cnt++;
	}
}

```


###

#### 题目大意：快速排序中，我们通常采用某种方法取一个元素作为主元，通过交换，把比主元小的元素放到它的左边，比主元大的元素放到它的右边。 给定划分后的N个互不相同的正整数的排列，请问有多少个元素可能是划分前选取的主元？例如给定N = 5, 排列是1、3、2、4、5。则：
* 1的左边没有元素，右边的元素都比它大，所以它可能是主元；
* 尽管3的左边元素都比它小，但是它右边的2它小，所以它不能是主元；
* 尽管2的右边元素都比它大，但其左边的3比它大，所以它不能是主元；
* 类似原因，4和5都可能是主元。
#### 因此，有3个元素可能是主元。 给N个数，第一行输出可能是主元的个数，第二行输出这些元素～


```
int leftmax[100010],rightmin[100010],a[100010];
/*
leftmax 记录i号元素左边的最大元素
rightmin 记录i号元素右边的最小元素

num 记录结果数组
*/
int num[100010];

int main(){

    int n,cnt=0;
    scanf("%d",&n);
    for(int i=0;i<n;i++)
        scanf("%d",&a[i]);
    leftmax[0]=0;
    for(int i=1;i<n;i++)
        leftmax[i]=max(leftmax[i-1],a[i-1]);

    rightmin[n-1]=inf;
    for(int i=n-2;i>=0;i--)
        rightmin[i]=min(rightmin[i+1],a[i+1]);

    cnt=0;
    for(int i=0;i<n;i++){
        if(leftmax[i]<a[i]&&a[i]<rightmin[i]){
        ///如果一个元素大于左边最大的元素，小于右边最小的元素
            num[cnt++]=a[i];
        }
    }

```







