
### 1103 Integer Factorization (30分)

* 1，初始化所需数组

```
vector<int> fac, ans, temp;//最优底数序列和临时序列
/**
求n^p
**/
int power(int x) {
    int ans = 1;
    for (int i = 0; i < p; i++) {
        ans *= x;
    }
    return ans;
}
/**
初始化fac数组注意0
**/
void init() {
    int i = 0, tmp = 0;
    while (tmp <= n) {
        fac.push_back(tmp);
        tmp = power(++i);
    }
}
```

* 2，```DFS```（和《算法笔记》上的```DFS```一致）

```
/**
DFS函数
index: 当前访问；
nowK:当前选中个数
sum:当前的数的和
facSum:当前的底数的和, n1 + n2 +... + nk;
**/
 
void DFS(int index, int nowK, int sum, int facSum) {
    if (sum > n || nowK > k) return;
    if (sum == n && nowK == k) {
        if (facSum > maxFacSum) {
            maxFacSum = facSum;
            ans = temp;
        }
        return;
    }
    if (index - 1 >= 0) {//fac[0]不需要
        //选index
        temp.push_back(index);
        DFS(index, nowK + 1, sum + fac[index], facSum + index);
        //不选index
        temp.pop_back();
        DFS(index - 1, nowK, sum, facSum);
    }
}

```
* 3，取```-1```，省去了标志位，来记录是否存在满足题意的序列
```
int maxFacSum = -INF;//最大底数之和
```

* [《算法笔记题解》](https://blog.csdn.net/qq_34649947/article/details/81208186)


* [《算法笔记》```DFS```型解法（掌握）](https://blog.csdn.net/qq_33375598/article/details/104085131)


















