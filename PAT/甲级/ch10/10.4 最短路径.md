### 1003 Emergency (25分)
* 邻接表版
* 邻接矩阵版
* 输出的第一个数是最短路径条数，而不是最短距离
* ```d[u]+adj[u][j].dis==d[v]```时，无论```w[u]+weight[v]>w[v]```是否成立，都应当让```num[v]+=num[u]```，因为最短路径条数的依据仅是第一标尺距离，与点权无关

```
for(int j=0;j<(int)adj[u].size();j++){
   int v=adj[u][j].v;
   if(vis[v]==false){
       if(d[u]+adj[u][j].dis<d[v]){
           d[v]=d[u]+adj[u][j].dis;
           w[v]=w[u]+weight[v];
           num[v]=num[u];
       }
       else if(d[u]+adj[u][j].dis==d[v]){///找到一条相同长度的路径
           if(w[u]+weight[v]>w[v]){
                w[v]=w[u]+weight[v];
           }
           num[v]+=num[u];///最短路径条数与点权无关，必须写在外面
       }
   }
}

```

### 1018 Public Bike Management (30分)




### 1030 Travel Plan (30分)

* ```DFS```计算边权之和时，只需要访问```n-1```条边，因此如果倒着访问，那么循环条件应为```i>0```；如果是正着访问，那么循环条件应为```i<tempPath.size()-1```
* ```Dijsktra + DFS```,```Dijsktra```计算最短路径，```DFS```计算最少花费路径
```
///
void DFS(int v){
    tempath.push_back(v);
    if(v==st){
        int tempcost=0;
        for(int i=tempath.size()-1;i>0;i--){
            int id=tempath[i],nextid=tempath[i-1];
            tempcost+=cost[id][nextid];
        }
        if(mincost>tempcost){
            mincost=tempcost;
            ans=tempath;
        }
        tempath.pop_back();
        return ;
    }
    for(int i=0;i<(int)pre[v].size();i++){
        DFS(pre[v][i]);
    }
    tempath.pop_back();
    return ;
}

```

* ```Dijsktra```既计算最短路径，又计算最少花费路径

```
void DFS(int v){
   if(v==st){
      printf("%d",v);
      return ;
   }
   DFS(pre[v]);
   printf("%d ",v);
}

```

### 1072 Gas Station (30分)

* 思路：```Dijsktra```的简单应用,难点在于处理数据


























