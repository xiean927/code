

* 并查集解法
```
#include <bits/stdc++.h>

using namespace std;

const int maxn=1010;

vector<int> e[maxn];
int n,m,k;///城市总数,仍存在的道路数,需要被检查的城市数
int father[maxn];
bool vis[maxn];

int findfather(int x){
    int a=x;
    while(x!=father[x])
        x=father[x];
    while(a!=father[a]){
        int z=a;
        a=father[a];
        father[z]=x;
    }
    return x;
}

void union_(int a,int b){
    int faA=findfather(a);
    int faB=findfather(b);
    if(faA!=faB)
        father[faA]=faB;
}

void init(){
    for(int i=1;i<maxn;i++){
        father[i]=i;
        vis[i]=false;
    }
}

int main(){
    scanf("%d%d%d",&n,&m,&k);
    for(int i=0;i<m;i++){
        int a,b;
        scanf("%d%d",&a,&b);
        e[a].push_back(b);
        e[b].push_back(a);
    }
    int opp;
    for(int query=0;query<k;query++){
        scanf("%d",&opp);
        init();
        for(int i=1;i<=n;i++){
            for(int j=0;j<(int)e[i].size();j++){
                int u=i,v=e[i][j];
                if(u==opp||v==opp)  continue;
                union_(u,v);
            }
        }
        int block=0;
        for(int i=1;i<=n;i++){
            if(i==opp)  continue;
            int fa_i=findfather(i);
            if(vis[fa_i]==false){
                vis[fa_i]=true;
                block++;
            }
        }
        printf("%d\n",block-1);
    }

    return 0;
}

```


* 1021 Deepest Root (25分)













