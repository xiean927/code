

#### 1067 Sort with Swap(0, i) (25分)
##### 与2019秋甲级题目类似DFS遍历```left```记录已排好序的位数



#### 1085 Perfect Sequence (25分)

```
int left=n-1,num;///left 记录不在本位上的数的数目

for(int i=0;i<n;i++){
  scanf("%d",&num);
  a[num]=i;///num所处的位置是i
  if(num==i&&num!=0)///如果除0以外有本位上的数
    left--;///left减1
}
int k=1;///k存放除0以外当前不在本位的最小的数的下标
int cnt=0;///总的交换次数
while(left>0){///只要还有数不在本位上
      ///如果0在本位上，则寻找一个当前不在本位上的数与0交换
  if(a[0]==0){
    while(k<n){
    //int k;
    //for(int i=1;i<n;i++)
          //if(a[i]!=i){
          //    k=i;
          //    break;
          //}
                  if(a[k]!=k){///找到一个不在本位上的数
                      swap(a[0],a[k]);///将k与0交换位置
                      cnt++;///交换次数加1
                      break;
                  }
                  k++;///判断k+1是否在本位上
              }
          }
  ///只要0不在本位上，就将0所在位置的数的当前所处位置与0的位置交换
  while(a[0]!=0){
    int t=a[0];///0所在位置
    swap(a[t],a[0]);///将0与pos[0]交换，
                          /// a[7]=2,a[0]=7
                          /// a[2]=3,a[0]=2,
                          /// a[3]=0,a[0]=3
                          ///
    cnt++;
    left--;///不在本位上的数的个数减1
  }
}
```


#### 1093 Count PAT's (25分) 
##### 类似题目```1101 Quick Sort (25分)```
```
int numleftP[maxn];///记录i位置左边 P 的个数
char line[maxn];

for(int i=0;i<len;i++){
  if(i>0)//顺序不能颠倒
    numleftP[i]=numleftP[i-1];
  if(line[i]=='P')
    numleftP[i]++;
}

int numrighT=0,ans=0;
  ///从右至左计算 T 的个数，与numleftP相乘
for(int i=len-1;i>=0;i--){
  if(line[i]=='T')
    numrighT++;
  else if(line[i]=='A')
    ans=(ans+numrighT*numleftP[i])%mod;
}

```


#### 1101 Quick Sort (25分)

##### 题目大意：快速排序中，我们通常采用某种方法取一个元素作为主元，通过交换，把比主元小的元素放到它的左边，比主元大的元素放到它的右边。 给定划分后的N个互不相同的正整数的排列，请问有多少个元素可能是划分前选取的主元？例如给定N = 5, 排列是1、3、2、4、5。则：
* 1的左边没有元素，右边的元素都比它大，所以它可能是主元；
* 尽管3的左边元素都比它小，但是它右边的2它小，所以它不能是主元；
* 尽管2的右边元素都比它大，但其左边的3比它大，所以它不能是主元；
* 类似原因，4和5都可能是主元。
##### 因此，有3个元素可能是主元。 给N个数，第一行输出可能是主元的个数，第二行输出这些元素～


```
int leftmax[100010],rightmin[100010],a[100010];
/*
leftmax 记录i号元素左边（不包括i）的最大元素
rightmin 记录i号元素右边（不包括i）的最小元素

num 记录结果数组
*/
int num[100010];

int main(){

    int n,cnt=0;
    scanf("%d",&n);
    for(int i=0;i<n;i++)
        scanf("%d",&a[i]);
    leftmax[0]=0;
    for(int i=1;i<n;i++)
        leftmax[i]=max(leftmax[i-1],a[i-1]);

    rightmin[n-1]=inf;
    for(int i=n-2;i>=0;i--)
        rightmin[i]=min(rightmin[i+1],a[i+1]);

    cnt=0;
    for(int i=0;i<n;i++){
        if(leftmax[i]<a[i]&&a[i]<rightmin[i]){
        ///如果一个元素大于左边最大的元素，小于右边最小的元素
            num[cnt++]=a[i];
        }
    }

```



#### 1112 Stucked Keyboard (20分)

##### 1，只要是未破碎的键盘字就得记录下来，说明这个键不是坏键，最后处理
##### 2，如何输出具有坏键的字符串
```
for(int i=0;i<len;i++){///输出初始序列
    printf("%c",line[i]);
    if(mp[line[i]])
        i=i+k-1;
}
```


```
map<char,bool> mp,suremp;

int main(){
    cin>>k>>line;
    int len=line.size(),cnt=1;///cnt记录字母连续出现次数
    char pre=line[0];
    for(int i=1;i<len;i++){///i必须从1开始,
        if(pre!=line[i]){
            if(cnt%k!=0)///只要是未破碎的键盘字就得记录下来，最后处理，
                suremp[pre]=true;
            cnt=1;
        }
        else
            cnt++;
        mp[line[i]]=(cnt%k==0);///若字符line[i]的出现次数可以被k整除，则说明是坏键
        pre=line[i];///
    }
    for(int i=0;i<len;i++)
        if(suremp[line[i]]==true)///如果确定不是坏键,则更新mp映射
            mp[line[i]]=false;

    set<char> st;
    for(int i=0;i<len;i++){///打印坏键
        if(mp[line[i]]&&st.find(line[i])==st.end()){
            printf("%c",line[i]);
            st.insert(line[i]);
        }
    }
    
    printf("\n");
    for(int i=0;i<len;i++){///输出初始序列
        printf("%c",line[i]);
        if(mp[line[i]])
            i=i+k-1;
    }

```

#### 1129 Recommendation System (25分)（WA）


##### 不能写成```vector<Item>```，利用```bool cmp()```排序，超时；必须用```set```

```
struct Item{
    int cnt;///出现次数
    int index;///编号
    bool operator<(const Item &a)const {
        if(cnt!=a.cnt)
            return cnt>a.cnt;
        else
            return index<a.index;
    }
};

```

##### 为什么不能加???

```
item.cnt=book[inpdex];
item.index=inpdex;

```





