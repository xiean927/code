
* [DFS+剪枝](https://blog.csdn.net/sm20170867238/article/details/89946300)

```
#include <bits/stdc++.h>

using namespace std;

const int maxn=10010;

int arr[maxn],sum_[maxn];///sum_记录从位置i之后的元素和(包括位置i)
int take[maxn];
int n,m;
bool flag=false;

void Dfs(int x,int num,int sum){
	if(flag||sum+sum_[x]<m) //如果当前的值sum加上剩下所有钱都不足m则不继续递归
		return;
	if(x==n||sum>=m){//如果当前值大于m则不继续递归
		if(sum==m){
			flag=true;//标记，结束所有递归
			printf("%d",take[0]);
			for(int i=1;i<num;i++)
				printf(" %d",take[i]);
			printf("\n");
		}
		return;
	}
	
	take[num]=arr[x];
	Dfs(x+1,num+1,sum+arr[x]);//取当前硬币
	Dfs(x+1,num,sum);//不取当前硬币
	
}
int main(){

    scanf("%d %d",&n,&m);
	for(int i=0;i<n;i++)
		scanf("%d",&arr[i]);
	sort(arr,arr+n);

	sum_[n-1]=arr[n-1];
	for(int i=n-2;i>=0;i--) //计算后缀和
		sum_[i]=sum_[i+1]+arr[i];

	Dfs(0,0,0);
	if(!flag)
		printf("No Solution\n");

	return 0;
}

```
