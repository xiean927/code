
### 思路

* 我的代码，```map```无法查找，也就是无法输出```NA```，名字不存在的情况
* 对于是否在几代内通婚，无法判断
```
#include <bits/stdc++.h>

using namespace std;

const int maxn=100010;

struct Person{
    string firname,secname;
    string ori_sname;
    int gender;///0,男;1,女
}per[maxn];
map<string,int> fir_index;///名 映射 per数组编号
int n,m;

int main(){

    scanf("%d",&n);
    for(int i=0;i<n;i++){
        cin>>per[i].firname>>per[i].secname;
        int slen=per[i].secname.size();
        if(per[i].secname[slen-1]=='f'){
            per[i].gender=1;
            per[i].ori_sname=per[i].secname.substr(0,slen-1);
        }
        else if(per[i].secname[slen-1]=='m'){
            per[i].gender=0;
            per[i].ori_sname=per[i].secname.substr(0,slen-1);
        }
        else if(per[i].secname.find("sson")!=string::npos){
            per[i].gender=0;
            per[i].ori_sname=per[i].secname.substr(0,slen-4);
        }
        else if(per[i].secname.find("sdottir")!=string::npos){
            per[i].gender=1;
            per[i].ori_sname=per[i].secname.substr(0,slen-7);
        }
        fir_index[per[i].firname]=i;
        //cout<<per[i].ori_sname<<endl;
    }
    string fir1,sec1,fir2,sec2;
    scanf("%d",&n);

    for(int i=0;i<n;i++){
        cin>>fir1>>sec1>>fir2>>sec2;
        int index1=fir_index[fir1];
        int index2=fir_index[fir2];///获取编号
        if(per[index1].gender==per[index2].gender){
        ///若两人为同性，则输出 Whatever；
            printf("Whatever\n");
        }
        else if(fir_index.find(fir1)==fir_index.end()||
                fir_index.find(fir2)==fir_index.end()){
        ///若有一人不在名单内，则输出 NA。
            printf("NA\n");
        }
        else{
            //printf("1\n");
        }
        //cout<<fir1<<" "<<fir2<<endl;
        cout<<(fir_index.count(fir1)>0)<<endl;
        cout<<(fir_index.count(fir2)>0)<<endl;
    }

    return 0;
}

```
https://blog.csdn.net/daixinliangwyx/article/details/89857318

https://blog.csdn.net/weixin_43264529/article/details/88925108







