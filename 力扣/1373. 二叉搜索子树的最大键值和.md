
* 思路
  * 判断是否为二叉搜索树，然后 计算权值
  * 但结果不对
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    int maxSum = INT_MIN;
public:
    int isBST(TreeNode* node){
        if(node->left == nullptr && node->right == nullptr)
            return 1;
        else if(node->left != nullptr && node->right == nullptr){
            if(node->left->val < node->val)
                return 1;
            else
                return 0;
        }
        else if(node->right != nullptr && node->left == nullptr){
            if(node->val < node->right->val)
                return 1;
            else
                return 0;
        }
        else{
            if(node->left->val < node->val && node->val < node->right->val)
                return 1;
            else
                return 0;
        }
        
    }

    int maxGain(TreeNode* node){
        if(node == nullptr)
            return 0;
        
        // 递归计算左右子节点的最大贡献值
        // 只有再最大贡献值大于 0 时，才会选取对应子节点
        int leftGain=0,rightGain=0;
        if(isBST(node->left))
            leftGain = max(maxGain(node->left), 0);
        else
            leftGain = 0;
        if(isBST(node->right))
            rightGain = max(maxGain(node->right), 0);
        else
            rightGain = 0;

        // 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值
        int priceNewpath = node->val + leftGain + rightGain;

        //更新答案
        maxSum = max(maxSum, priceNewpath);

        // 返回节点的最大贡献值
        return node->val + max(leftGain, rightGain);
    }
    int maxSumBST(TreeNode* root) {
        maxGain(root);
        return maxSum;
    }
};
```












